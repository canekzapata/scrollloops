<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Fractal Scrolls</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>
    html, body {
      margin: 0;
      padding: 0;
      width: 100vw;
      height: 100vh;
      overflow: hidden;
      background-color: #000;
      font-family: monospace;
      perspective: 1000px;
      perspective-origin: 50% 50%;
    }

    #fractal-container {
      position: absolute;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      transform-style: preserve-3d;
    }

    .fractal-div {
      position: absolute;
      overflow: auto;
      border: 1px solid;
      box-sizing: border-box;
      /* clip-path morphing benefits from its own transition timing */
      transition: background 0.6s ease-in-out,
                  border-color 0.6s ease-in-out,
                  transform 0.5s ease-in-out,
                  opacity 0.5s ease-in-out,
                  clip-path 1.2s ease-in-out,
                  border-radius 1.2s ease-in-out,
                  box-shadow 0.4s ease-in-out;
      transform-style: preserve-3d;
      backface-visibility: visible;
    }

    .fractal-div::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }

    .fractal-div::-webkit-scrollbar-track {
      background: rgba(0,0,0,0.3);
      border-radius: 4px;
    }

    .fractal-div::-webkit-scrollbar-thumb {
      border-radius: 4px;
      transition: background 0.3s ease;
    }

    .fractal-div::-webkit-scrollbar-corner {
      background: rgba(0,0,0,0.3);
    }

    @keyframes float-around {
      0%   { transform: translateX(0px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(0deg); }
      25%  { transform: translateX(200px) translateY(-100px) translateZ(150px) rotateX(15deg) rotateY(45deg); }
      50%  { transform: translateX(-150px) translateY(150px) translateZ(-50px) rotateX(-20deg) rotateY(90deg); }
      75%  { transform: translateX(100px) translateY(-200px) translateZ(200px) rotateX(30deg) rotateY(135deg); }
      100% { transform: translateX(0px) translateY(0px) translateZ(0px) rotateX(0deg) rotateY(180deg); }
    }

    @keyframes dramatic-flip {
      0%   { transform: rotateX(0deg) rotateY(0deg) translateZ(0px) scale3d(1, 1, 1); }
      25%  { transform: rotateX(90deg) rotateY(45deg) translateZ(300px) scale3d(0.5, 2, 0.5); }
      50%  { transform: rotateX(180deg) rotateY(90deg) translateZ(-100px) scale3d(2, 0.3, 1.5); }
      75%  { transform: rotateX(270deg) rotateY(135deg) translateZ(250px) scale3d(0.3, 1.8, 0.8); }
      100% { transform: rotateX(360deg) rotateY(180deg) translateZ(0px) scale3d(1, 1, 1); }
    }

    @keyframes spiral-movement {
      0%   { transform: translateX(0px) translateY(0px) translateZ(0px) rotateZ(0deg); }
      25%  { transform: translateX(150px) translateY(150px) translateZ(100px) rotateZ(90deg) rotateX(45deg); }
      50%  { transform: translateX(0px) translateY(300px) translateZ(-150px) rotateZ(180deg) rotateX(90deg); }
      75%  { transform: translateX(-150px) translateY(150px) translateZ(200px) rotateZ(270deg) rotateX(135deg); }
      100% { transform: translateX(0px) translateY(0px) translateZ(0px) rotateZ(360deg) rotateX(180deg); }
    }

    @keyframes extreme-stretch {
      0%   { width: var(--base-width); height: var(--base-height); transform: rotateY(0deg) translateZ(0px) scaleX(1) scaleY(1); }
      25%  { width: calc(var(--base-width) * 3); height: calc(var(--base-height) * 0.2); transform: rotateY(60deg) translateZ(150px) scaleX(1.5) scaleY(0.1); }
      50%  { width: calc(var(--base-width) * 0.1); height: calc(var(--base-height) * 4); transform: rotateY(120deg) translateZ(-100px) scaleX(0.1) scaleY(2); }
      75%  { width: calc(var(--base-width) * 2.5); height: calc(var(--base-height) * 0.3); transform: rotateY(240deg) translateZ(200px) scaleX(2) scaleY(0.2); }
      100% { width: var(--base-width); height: var(--base-height); transform: rotateY(360deg) translateZ(0px) scaleX(1) scaleY(1); }
    }

    @keyframes wobble-drift {
      0%   { transform: translateX(0px) translateY(0px) rotateX(0deg) rotateY(0deg) rotateZ(0deg); }
      20%  { transform: translateX(80px) translateY(-60px) rotateX(20deg) rotateY(-15deg) rotateZ(10deg); }
      40%  { transform: translateX(-120px) translateY(100px) rotateX(-25deg) rotateY(30deg) rotateZ(-20deg); }
      60%  { transform: translateX(160px) translateY(80px) rotateX(15deg) rotateY(-25deg) rotateZ(15deg); }
      80%  { transform: translateX(-80px) translateY(-120px) rotateX(-30deg) rotateY(20deg) rotateZ(-10deg); }
      100% { transform: translateX(0px) translateY(0px) rotateX(0deg) rotateY(0deg) rotateZ(0deg); }
    }

    @keyframes perspective-dance {
      0%   { transform: perspective(800px) rotateX(0deg) rotateY(0deg) translateZ(0px); }
      16%  { transform: perspective(800px) rotateX(45deg) rotateY(30deg) translateZ(100px); }
      33%  { transform: perspective(800px) rotateX(-30deg) rotateY(60deg) translateZ(-80px); }
      50%  { transform: perspective(800px) rotateX(60deg) rotateY(-45deg) translateZ(150px); }
      66%  { transform: perspective(800px) rotateX(-45deg) rotateY(90deg) translateZ(-120px); }
      83%  { transform: perspective(800px) rotateX(30deg) rotateY(-60deg) translateZ(80px); }
      100% { transform: perspective(800px) rotateX(0deg) rotateY(0deg) translateZ(0px); }
    }

    .fractal-div:hover {
      z-index: 10;
      box-shadow: 0 0 20px rgba(255,255,255,0.3);
    }

    .fractal-div.scrolling {
      border-width: 3px;
      box-shadow: 0 0 15px rgba(255,255,255,0.5);
    }
  </style>
</head>
<body>
  <div id="fractal-container"></div>

  <script>
    // ─── GLOBALS ────────────────────────────────────────────────────────────────
    let motherDivs = 0;
    const MAX_MOTHER_DIVS = 6;
    const MAX_CHILDREN_PER_MOTHER = 8;

    // Golden angle: irrational, so a sequence of hue rotations never repeats
    const GOLDEN_ANGLE = 137.508;

    // Global base hue that rotates 1° per second — whole composition drifts slowly
    let globalBaseHue = Math.random() * 360;
    setInterval(() => { globalBaseHue = (globalBaseHue + 1) % 360; }, 1000);

    // ─── SHAPES ─────────────────────────────────────────────────────────────────
    // Shapes natural to divs (rect/square) — the default form
    const RECTANGULAR_SHAPES = [
      { clipPath: 'none', borderRadius: '0%' },  // rect / square
    ];

    // Non-natural shapes — used sparingly (premium feel)
    // clip-path morphing is smooth only between polygons with the same vertex count.
    const NON_RECTANGULAR_SHAPES = [
      { clipPath: 'none', borderRadius: '50%' },                                   // circle
      { clipPath: 'none', borderRadius: '60% 40% 30% 70% / 60% 30% 70% 40%' },   // organic blob
      { clipPath: 'none', borderRadius: '30% 70% 70% 30% / 30% 30% 70% 70%' },   // organic blob 2

      // 3-vertex polygons
      { clipPath: 'polygon(50% 0%, 0% 100%, 100% 100%)',   borderRadius: '0%' },  // triangle up
      { clipPath: 'polygon(50% 100%, 0% 0%, 100% 0%)',     borderRadius: '0%' },  // triangle down

      // 4-vertex polygons
      { clipPath: 'polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%)', borderRadius: '0%' }, // diamond
      { clipPath: 'polygon(15% 0%, 85% 0%, 100% 100%, 0% 100%)', borderRadius: '0%' }, // trapezoid

      // 5-vertex polygons
      { clipPath: 'polygon(50% 0%, 100% 38%, 82% 100%, 18% 100%, 0% 38%)', borderRadius: '0%' }, // pentagon

      // 6-vertex polygons
      { clipPath: 'polygon(25% 0%, 75% 0%, 100% 50%, 75% 100%, 25% 100%, 0% 50%)', borderRadius: '0%' }, // hexagon

      // 10-vertex star
      { clipPath: 'polygon(50% 0%, 61% 35%, 98% 35%, 68% 57%, 79% 91%, 50% 70%, 21% 91%, 32% 57%, 2% 35%, 39% 35%)', borderRadius: '0%' },
    ];

    // isParent = true  → 5%  chance of non-rectangular shape (premium rarity)
    // isParent = false → 25% chance of non-rectangular shape (still relatively rare)
    function applyShape(div, isParent = false) {
      const threshold = isParent ? 0.05 : 0.25;
      const pool = Math.random() < threshold ? NON_RECTANGULAR_SHAPES : RECTANGULAR_SHAPES;
      const shape = pool[randInt(0, pool.length - 1)];
      div.style.clipPath = shape.clipPath;
      div.style.borderRadius = shape.borderRadius;
    }

    // ─── RANDOM HELPERS ─────────────────────────────────────────────────────────
    function rand(min, max) { return Math.random() * (max - min) + min; }
    function randInt(min, max) { return Math.floor(rand(min, max + 1)); }

    // ─── HARMONIC COLOR SYSTEM ──────────────────────────────────────────────────
    // Instead of random RGB, we anchor to a baseHue and vary hue ±20°,
    // keeping saturation/lightness in expressive but coherent ranges.
    function harmonicColor(baseHue, alpha = null) {
      const h = ((baseHue + rand(-20, 20)) + 360) % 360;
      const s = rand(55, 90);
      const l = rand(35, 68);
      const a = alpha !== null ? alpha : rand(0.2, 0.85);
      return `hsla(${h.toFixed(1)}, ${s.toFixed(1)}%, ${l.toFixed(1)}%, ${a.toFixed(2)})`;
    }

    // Gradient built from golden-angle hue steps rooted at baseHue
    function createHarmonicGradient(baseHue) {
      const angle = randInt(0, 360);
      const hue2 = (baseHue + GOLDEN_ANGLE) % 360;
      const hue3 = (baseHue + GOLDEN_ANGLE * 2) % 360;

      const c1 = harmonicColor(baseHue, rand(0.2, 0.8));
      const c2 = harmonicColor(hue2,    rand(0.2, 0.8));
      const c3 = harmonicColor(hue3,    rand(0.2, 0.8));

      const t = Math.random();
      if (t < 0.28) return `linear-gradient(${angle}deg, ${c1}, ${c2})`;
      if (t < 0.50) return `linear-gradient(${angle}deg, ${c1}, ${c2}, ${c3})`;
      if (t < 0.68) return `radial-gradient(circle at ${randInt(10,90)}% ${randInt(10,90)}%, ${c1}, ${c2})`;
      if (t < 0.86) return `radial-gradient(circle at ${randInt(10,90)}% ${randInt(10,90)}%, ${c1}, ${c2}, ${c3})`;
      return `conic-gradient(from ${angle}deg, ${c1}, ${c2}, ${c3})`;
    }

    // ─── CREATE FRACTAL DIV ─────────────────────────────────────────────────────
    // hue: parent's hue — children get hue + GOLDEN_ANGLE, creating harmonic families
    function createFractalDiv(parentEl, parentWidth, parentHeight, depth = 0, maxDepth = 4, hue = null) {
      if (depth > maxDepth) return;

      const myHue = hue !== null ? hue : globalBaseHue;
      const childHue = (myHue + GOLDEN_ANGLE) % 360;

      const div = document.createElement('div');
      div.className = 'fractal-div';
      div.dataset.hue = myHue.toFixed(2);

      if (depth === 0) {
        div.setAttribute('data-mother', 'true');
        motherDivs++;
      } else {
        div.setAttribute('data-child-level', depth);
      }

      // Dimensions
      let divWidth, divHeight;
      if (depth === 0) {
        divWidth  = rand(parentWidth  * 0.25, parentWidth  * 0.43);
        divHeight = rand(parentHeight * 0.35, parentHeight * 0.53);
      } else {
        divWidth  = rand(parentWidth  * 0.2, parentWidth  * 0.4);
        divHeight = rand(parentHeight * 0.2, parentHeight * 0.4);
      }

      const contentWidth  = divWidth  * rand(2.5, 4);
      const contentHeight = divHeight * rand(2.5, 4);

      const x = rand(0, parentWidth  - divWidth);
      const y = rand(0, parentHeight - divHeight);

      // Harmonic colors derived from myHue
      const borderColor = harmonicColor(myHue, rand(0.5, 0.9));
      const scrollColor = harmonicColor(myHue, 0.8);

      div.style.position   = 'absolute';
      div.style.left       = x + 'px';
      div.style.top        = y + 'px';
      div.style.width      = divWidth  + 'px';
      div.style.height     = divHeight + 'px';
      div.style.borderColor = borderColor;
      div.style.borderWidth = randInt(1, 3) + 'px';
      div.style.borderStyle = 'solid';
      div.style.overflow   = 'auto';
      div.style.boxSizing  = 'border-box';
      div.style.background = createHarmonicGradient(myHue);
      div.style.setProperty('--base-width',  divWidth  + 'px');
      div.style.setProperty('--base-height', divHeight + 'px');
      div.style.scrollbarColor = `${scrollColor} rgba(0,0,0,0.3)`;

      // Apply a geometric shape — parents rarely non-rectangular (5%), children sometimes (25%)
      applyShape(div, depth === 0);

      // Internal scrollable content
      const content = document.createElement('div');
      content.style.width      = contentWidth  + 'px';
      content.style.height     = contentHeight + 'px';
      content.style.background = createHarmonicGradient(childHue);
      content.style.position   = 'relative';

      div.appendChild(content);
      parentEl.appendChild(div);

      // ── Scroll → harmonic color shift ──────────────────────────────────────
      div.addEventListener('scroll', () => {
        div.classList.add('scrolling');

        const scrollPercentX = div.scrollLeft / (div.scrollWidth - div.clientWidth || 1);
        const scrollPercentY = div.scrollTop  / (div.scrollHeight - div.clientHeight || 1);

        // Scroll position shifts hue within the harmonic family
        const baseH = parseFloat(div.dataset.hue) || globalBaseHue;
        const hue1  = (baseH + scrollPercentX * 60) % 360;
        const hue2  = (baseH + GOLDEN_ANGLE + scrollPercentY * 60) % 360;
        const hue3  = (baseH + GOLDEN_ANGLE * 2) % 360;

        const sc1 = harmonicColor(hue1, rand(0.4, 0.8));
        const sc2 = harmonicColor(hue2, rand(0.4, 0.8));
        const sc3 = harmonicColor(hue3, rand(0.4, 0.8));

        if (Math.random() > 0.4) {
          div.style.background = `linear-gradient(${(scrollPercentX * 360).toFixed(0)}deg, ${sc1}, ${sc2}, ${sc3})`;
        } else {
          div.style.background = `radial-gradient(circle at ${(scrollPercentX*100).toFixed(0)}% ${(scrollPercentY*100).toFixed(0)}%, ${sc1}, ${sc2})`;
        }

        div.style.borderColor = sc3;
        setTimeout(() => div.classList.remove('scrolling'), 300);

        const scrollbarH = (hue1 + hue2) / 2;
        div.style.scrollbarColor = `${harmonicColor(scrollbarH, 0.8)} rgba(0,0,0,0.3)`;
      });

      // ── Hover ───────────────────────────────────────────────────────────────
      div.addEventListener('mouseenter', () => {
        const h = parseFloat(div.dataset.hue) || globalBaseHue;
        div.style.borderColor = harmonicColor(h, 1);
        div.style.background  = createHarmonicGradient(h);
      });

      // ── Spawn children ──────────────────────────────────────────────────────
      if (depth < maxDepth) {
        let numChildren;
        if (depth === 0)      numChildren = randInt(4, MAX_CHILDREN_PER_MOTHER);
        else if (depth === 1) numChildren = randInt(2, 4);
        else                  numChildren = randInt(1, 3);

        for (let i = 0; i < numChildren; i++) {
          setTimeout(() => {
            createFractalDiv(content, contentWidth, contentHeight, depth + 1, maxDepth, childHue);
          }, rand(200, 1000));
        }
      }

      return div;
    }

    // ─── AUTO-SCROLL ─────────────────────────────────────────────────────────────
    function autoScroll() {
      setInterval(() => {
        const allDivs = document.querySelectorAll('.fractal-div');
        if (allDivs.length === 0) return;

        const shuffled = Array.from(allDivs).sort(() => 0.5 - Math.random());
        const divsToScroll = shuffled.slice(0, Math.floor(allDivs.length * 0.85));

        divsToScroll.forEach(div => {
          const dir      = Math.random() > 0.5 ? 'scrollTop' : 'scrollLeft';
          const amount   = randInt(70, 400);
          const target   = Math.max(0, div[dir] + (Math.random() > 0.5 ? amount : -amount));
          const start    = div[dir];
          const distance = target - start;
          const duration = rand(500, 2000);
          const t0       = Date.now();

          (function smoothScroll() {
            const p = Math.min((Date.now() - t0) / duration, 1);
            div[dir] = start + distance * (1 - Math.pow(1 - p, 3));
            if (p < 1) requestAnimationFrame(smoothScroll);
          })();
        });
      }, rand(1000, 8000));
    }

    // ─── TEMPORAL ANIMATION SYSTEM ───────────────────────────────────────────────
    function temporalAnimationSystem() {
      const animations = [
        'float-around', 'dramatic-flip', 'spiral-movement',
        'extreme-stretch', 'wobble-drift', 'perspective-dance'
      ];

      setInterval(() => {
        const allDivs = document.querySelectorAll('.fractal-div');
        const target  = Math.floor(allDivs.length * 0.5);
        let active    = Array.from(allDivs).filter(d => d.style.animation && d.style.animation !== 'none').length;

        allDivs.forEach(div => {
          if (Math.random() > 0.7) {
            if (active < target) {
              const anim = animations[randInt(0, animations.length - 1)];
              div.style.animation = `${anim} ${rand(8, 20).toFixed(1)}s ease-in-out infinite`;
              active++;
            } else if (active > target) {
              div.style.animation = 'none';
              div.style.transform = `translateX(${rand(-200,200).toFixed(0)}px) translateY(${rand(-200,200).toFixed(0)}px) translateZ(${rand(-150,150).toFixed(0)}px) rotateX(${rand(-25,25).toFixed(0)}deg) rotateY(${rand(-25,25).toFixed(0)}deg)`;
              active--;
            } else {
              if (Math.random() > 0.4) {
                const anim = animations[randInt(0, animations.length - 1)];
                div.style.animation = `${anim} ${rand(8, 20).toFixed(1)}s ease-in-out infinite`;
              } else {
                div.style.animation = 'none';
                div.style.transform = `translateX(${rand(-80,80).toFixed(0)}px) translateY(${rand(-80,80).toFixed(0)}px) translateZ(${rand(-60,60).toFixed(0)}px) rotateX(${rand(-20,20).toFixed(0)}deg) rotateY(${rand(-20,20).toFixed(0)}deg)`;
              }
            }
          }
        });
      }, rand(5000, 10000));
    }

    // ─── TEMPORAL Z-INDEX / 3D SYSTEM ────────────────────────────────────────────
    function temporalZIndexSystem() {
      setInterval(() => {
        const allDivs = document.querySelectorAll('.fractal-div');
        allDivs.forEach(div => {
          if (Math.random() > 0.6) {
            div.style.zIndex = randInt(1, 200);

            if (Math.random() > 0.5) {
              div.style.transform = `translateX(${rand(-300,300).toFixed(0)}px) translateY(${rand(-200,200).toFixed(0)}px) translateZ(${rand(-200,200).toFixed(0)}px) rotateX(${rand(-45,45).toFixed(0)}deg) rotateY(${rand(-45,45).toFixed(0)}deg)`;
            }

            if (Math.random() > 0.92) {
              div.style.zIndex    = randInt(500, 1000);
              const scale         = rand(0.5, 2);
              div.style.transform = `translateX(${rand(-700,600).toFixed(0)}px) translateY(${rand(-700,800).toFixed(0)}px) translateZ(${rand(550,700).toFixed(0)}px) rotateX(${rand(-60,60).toFixed(0)}deg) rotateY(${rand(-90,90).toFixed(0)}deg) scale3d(${scale.toFixed(2)},${scale.toFixed(2)},${scale.toFixed(2)})`;
              div.style.boxShadow = '0 0 60px rgba(255,255,255,0.9)';

              setTimeout(() => {
                div.style.boxShadow = 'none';
                div.style.transform = `translateX(${rand(-150,150).toFixed(0)}px) translateY(${rand(-100,100).toFixed(0)}px) translateZ(${rand(-80,80).toFixed(0)}px) rotateX(${rand(-20,20).toFixed(0)}deg) rotateY(${rand(-20,20).toFixed(0)}deg) scale3d(1,1,1)`;
              }, rand(4000, 12000));
            }
          }
        });
      }, rand(4000, 8000));
    }

    // ─── TEMPORAL GROWTH SYSTEM ──────────────────────────────────────────────────
    function temporalGrowthSystem() {
      setInterval(() => {
        const currentMothers = document.querySelectorAll('[data-mother="true"]').length;

        if (Math.random() > 0.3) {
          if (currentMothers < MAX_MOTHER_DIVS && Math.random() > 0.4) {
            const slots = MAX_MOTHER_DIVS - currentMothers;
            const n     = Math.min(randInt(1, 2), slots);

            for (let i = 0; i < n; i++) {
              setTimeout(() => {
                const container = document.getElementById('fractal-container');
                createFractalDiv(container, window.innerWidth, window.innerHeight, 0, 3);
              }, i * rand(2000, 5000));
            }
          }

          if (currentMothers > 2 && Math.random() > 0.8) {
            const mothers    = document.querySelectorAll('[data-mother="true"]');
            const toRemove   = mothers[randInt(0, mothers.length - 1)];
            if (toRemove && toRemove.parentNode) {
              toRemove.style.transition = 'opacity 3s ease-out, transform 3s ease-out';
              toRemove.style.opacity    = '0';
              toRemove.style.transform  = 'scale3d(0.3,0.3,0.3) translateZ(-300px) rotateY(180deg)';
              setTimeout(() => {
                if (toRemove.parentNode) toRemove.parentNode.removeChild(toRemove);
              }, 3000);
            }
          }
        }
      }, rand(15000, 25000));
    }

    // ─── TEMPORAL CLEANUP SYSTEM ─────────────────────────────────────────────────
    function temporalCleanupSystem() {
      setInterval(() => {
        const childDivs = document.querySelectorAll('[data-child-level]');
        if (childDivs.length > 80) {
          const n = Math.min(randInt(3, 8), childDivs.length);
          for (let i = 0; i < n; i++) {
            const child = childDivs[randInt(0, childDivs.length - 1)];
            if (child && child.parentNode) {
              child.style.transition = 'opacity 1.5s ease-out, transform 1.5s ease-out';
              child.style.opacity    = '0';
              child.style.transform  = 'scale3d(0.1,0.1,0.1) translateZ(-100px)';
              setTimeout(() => { if (child.parentNode) child.parentNode.removeChild(child); }, 1500);
            }
          }
        }
      }, rand(25000, 35000));
    }

    // ─── TEMPORAL PROPERTY SYSTEM ────────────────────────────────────────────────
    // Updates colors (harmonic) + shape morphing on a gentle timer
    function temporalPropertySystem() {
      setInterval(() => {
        const allDivs = document.querySelectorAll('.fractal-div');
        allDivs.forEach(div => {
          if (Math.random() > 0.7) {
            // Drift the div's hue 1 step along the golden-angle sequence
            const currentHue = parseFloat(div.dataset.hue) || globalBaseHue;
            const newHue     = (currentHue + GOLDEN_ANGLE * 0.1) % 360;
            div.dataset.hue  = newHue.toFixed(2);

            div.style.background  = createHarmonicGradient(newHue);
            div.style.borderColor = harmonicColor(newHue, rand(0.4, 0.9));
            div.style.borderWidth = randInt(1, 5) + 'px';

            const content = div.firstChild;
            if (content) content.style.background = createHarmonicGradient((newHue + GOLDEN_ANGLE) % 360);

            // Shape morph — 20% chance per updated div, respecting parent/child rarity rules
            if (Math.random() > 0.8) applyShape(div, div.dataset.mother === 'true');
          }
        });
      }, rand(4000, 8000));
    }

    // ─── INIT ────────────────────────────────────────────────────────────────────
    function init() {
      const container    = document.getElementById('fractal-container');
      const screenWidth  = window.innerWidth;
      const screenHeight = window.innerHeight;

      const initialCount = randInt(1, 3);

      for (let i = 0; i < initialCount; i++) {
        setTimeout(() => {
          createFractalDiv(container, screenWidth, screenHeight, 0, 3);
        }, i * rand(500, 1500));
      }

      // ↓ Was 3000ms — reduced to 500ms so systems start almost immediately
      setTimeout(() => {
        autoScroll();
        temporalAnimationSystem();
        temporalZIndexSystem();
        temporalGrowthSystem();
        temporalCleanupSystem();
        temporalPropertySystem();
      }, 500);
    }

    // ─── RESIZE ──────────────────────────────────────────────────────────────────
    window.addEventListener('resize', () => {
      document.querySelectorAll('.fractal-div').forEach(div => {
        if (Math.random() > 0.7) {
          const w = rand(window.innerWidth * 0.3, window.innerWidth * 0.8);
          const h = rand(window.innerHeight * 0.3, window.innerHeight * 0.8);
          div.style.width  = w + 'px';
          div.style.height = h + 'px';
          div.style.setProperty('--base-width',  w + 'px');
          div.style.setProperty('--base-height', h + 'px');
          div.style.left = rand(-w * 0.2, window.innerWidth  - w * 0.8) + 'px';
          div.style.top  = rand(-h * 0.2, window.innerHeight - h * 0.8) + 'px';
        }
      });
    });

    window.addEventListener('load', init);
  </script>
</body>
</html>
